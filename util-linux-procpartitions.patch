Mount has to read /proc/partitions in one gulp. It doesn't. Failed for me 
after a hard powerdown (oops) and the resulting fsck-the-world frenzy on 
startup, before the mount -a. Failure cause is identical (getting out of 
sync with the text at the 1K boundary), but failure mode not quite so 
drastic as it doesn't bail out like fsck does.

--- util-linux-2.11y/disk-utils/blockdev.c.procpartitions	2002-03-08 17:57:02.000000000 -0500
+++ util-linux-2.11y/disk-utils/blockdev.c	2003-01-13 14:28:41.000000000 -0500
@@ -290,6 +290,7 @@
 	char ptname[200];
 	char device[210];
 	int ma, mi, sz;
+	char iobuf[32*1024];
 
 	procpt = fopen(PROC_PARTITIONS, "r");
 	if (!procpt) {
@@ -297,6 +298,7 @@
 			progname, PROC_PARTITIONS);
 		exit(1);
 	}
+	setvbuf(procpt, iobuf, _IOFBF, sizeof(iobuf));
 
 	while (fgets(line, sizeof(line), procpt)) {
 		if (sscanf (line, " %d %d %d %[^\n ]",
--- util-linux-2.26/disk-utils/fdisk-list.c.orig	2015-02-10 10:49:46.346584245 +0100
+++ util-linux-2.26/disk-utils/fdisk-list.c	2015-02-23 21:04:01.522730338 +0100
@@ -198,6 +198,7 @@
 char *next_proc_partition(FILE **f)
 {
 	char line[128 + 1];
+	static char iobuf[32*1024];
 
 	if (!*f) {
 		*f = fopen(_PATH_PROC_PARTITIONS, "r");
@@ -205,6 +206,7 @@
 			warn(_("cannot open %s"), _PATH_PROC_PARTITIONS);
 			return NULL;
 		}
+		setvbuf(*f, iobuf, _IOFBF, sizeof(iobuf));
 	}
 
 	while (fgets(line, sizeof(line), *f)) {
