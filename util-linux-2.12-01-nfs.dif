
Miscellaneous nfs mount changes from Trond.

---

 util-linux-2.12-bfields/mount/Makefile   |    4 
 util-linux-2.12-bfields/mount/nfsmount.c | 1235 +++++++++++++++++++------------
 util-linux-2.12-bfields/mount/sundries.h |    1 
 util-linux-2.12-bfields/mount/umount.c   |    4 
 4 files changed, 794 insertions(+), 450 deletions(-)

diff -puN mount/Makefile~nfs mount/Makefile
--- util-linux-2.12/mount/Makefile~nfs	2004-10-13 13:51:44.000000000 -0400
+++ util-linux-2.12-bfields/mount/Makefile	2004-10-13 14:13:30.000000000 -0400
@@ -31,7 +31,7 @@
 
 LO_OBJS = lomount.o $(LIB)/xstrncpy.o
 CRYPT_OBJS = cryptsetup.o -lcryptsetup
-NFS_OBJS = nfsmount.o nfsmount_xdr.o nfsmount_clnt.o
+NFS_OBJS = nfsmount.o nfsmount_xdr.o
 GEN_FILES = nfsmount.h nfsmount_xdr.c nfsmount_clnt.c
 
 all: $(PROGS)
@@ -55,7 +55,7 @@
 
 umount: umount.o fstab.o sundries.o xmalloc.o realpath.o mntent.o \
 	getusername.o get_label_uuid.o mount_by_label.o mount_blkid.o \
-	version.o $(LIB)/env.o $(LO_OBJS) $(CRYPT_OBJS)
+	version.o $(LIB)/env.o $(NFS_OBJS) $(LO_OBJS) $(CRYPT_OBJS)
 	$(LINK) $^ -o $@ $(BLKID_LIB)
 
 swapon:	swapon.o version.o xmalloc.o \
diff -puN mount/nfsmount.c~nfs mount/nfsmount.c
--- util-linux-2.12/mount/nfsmount.c~nfs	2004-10-13 13:51:44.000000000 -0400
+++ util-linux-2.12-bfields/mount/nfsmount.c	2004-10-13 14:13:30.000000000 -0400
@@ -34,6 +34,7 @@
 
 #include "../defines.h"	/* for HAVE_rpcsvc_nfs_prot_h and HAVE_inet_aton */
 
+#include <ctype.h>
 #include <unistd.h>
 #include <stdio.h>
 #include <string.h>
@@ -72,11 +73,100 @@
 #define NFS_FHSIZE 32
 #endif
 
+#define MNT_SENDBUFSIZE ((u_int)2048)
+#define MNT_RECVBUFSIZE ((u_int)1024)
+
 static char *nfs_strerror(int stat);
 
 #define MAKE_VERSION(p,q,r)	(65536*(p) + 256*(q) + (r))
 
 #define MAX_NFSPROT ((nfs_mount_version >= 4) ? 3 : 2)
+#define MAX_MNTPROT ((nfs_mount_version >= 4) ? 3 : 2)
+#define HAVE_RELIABLE_TCP (nfs_mount_version >= 4)
+
+#ifndef HAVE_inet_aton
+#define inet_aton(a,b) (0)
+#endif
+
+typedef dirpath mnt2arg_t;
+typedef dirpath mnt3arg_t;
+typedef dirpath mntarg_t;
+
+typedef struct fhstatus  mnt2res_t;
+typedef struct mountres3 mnt3res_t;
+typedef union {
+	mnt2res_t nfsv2;
+	mnt3res_t nfsv3;
+} mntres_t;
+
+typedef struct {
+	char **hostname;
+	struct sockaddr_in saddr;
+	struct pmap pmap;
+} clnt_addr_t;
+
+/* RPC call timeout values */
+static const struct timeval TIMEOUT = { 20, 0 };
+static const struct timeval RETRY_TIMEOUT = { 3, 0 };
+
+/* Define the order in which to probe for UDP/TCP services */
+static const u_int *
+proto_probelist(const int use_tcp)
+{
+	static const u_int probe_both[] = { IPPROTO_TCP, IPPROTO_UDP, 0 };
+	static const u_int probe_udponly[] = { IPPROTO_UDP, 0 };
+	if (use_tcp)
+		return probe_both;
+	return probe_udponly;
+}
+
+/* Define the order in which NFS versions are probed on portmapper */
+static const u_long *
+nfs_probelist(const int vers)
+{
+	static const u_long nfs2_probe[] = { 2, 0};
+	static const u_long nfs3_probe[] = { 3, 2, 0};
+	switch (vers) {
+	case 3:
+		return nfs3_probe;
+	default:
+		return nfs2_probe;
+	}
+}
+
+/* Define the order in which Mountd versions are probed on portmapper */
+static const u_long *
+mnt_probelist(const int vers)
+{
+	static const u_long mnt1_probe[] = { 1, 2, 0 };
+	static const u_long mnt3_probe[] = { 3, 1, 2, 0 };
+	switch (vers) {
+	case 3:
+		return mnt3_probe;
+	default:
+		return mnt1_probe;
+	}
+}
+
+/* Map an NFS version into the corresponding Mountd version */
+static u_long
+nfsvers_to_mnt(const u_long vers)
+{
+	static const u_long nfs_to_mnt[] = { 0, 0, 1, 3 };
+	if (vers <= 3)
+		return nfs_to_mnt[vers];
+	return 0;
+}
+
+/* Map a Mountd version into the corresponding NFS version */
+static u_long
+mntvers_to_nfs(const u_long vers)
+{
+	static const u_long mnt_to_nfs[] = { 0, 2, 2, 3 };
+	if (vers <= 3)
+		return mnt_to_nfs[vers];
+	return 0;
+}
 
 static int
 linux_version_code(void) {
@@ -102,123 +192,558 @@ linux_version_code(void) {
  *	NFS_MOUNT_VERSION: these nfsmount sources at compile time
  *	nfs_mount_version: version this source and running kernel can handle
  */
+static int nfs_mount_version = NFS_MOUNT_VERSION;
+
 static int
 find_kernel_nfs_mount_version(void) {
 	static int kernel_version = -1;
-	int nfs_mount_version = NFS_MOUNT_VERSION;
+	int mnt_version = NFS_MOUNT_VERSION;
 
 	if (kernel_version == -1)
 		kernel_version = linux_version_code();
 
 	if (kernel_version) {
 	     if (kernel_version < MAKE_VERSION(2,1,32))
-		  nfs_mount_version = 1;
+		  mnt_version = 1;
 	     else if (kernel_version < MAKE_VERSION(2,2,18))
-		  nfs_mount_version = 3;
+		  mnt_version = 3;
 	     else if (kernel_version < MAKE_VERSION(2,3,0))
-		  nfs_mount_version = 4; /* since 2.2.18pre9 */
+		  mnt_version = 4; /* since 2.2.18pre9 */
 	     else if (kernel_version < MAKE_VERSION(2,3,99))
-		  nfs_mount_version = 3;
+		  mnt_version = 3;
 	     else
-		  nfs_mount_version = 4; /* since 2.3.99pre4 */
+		  mnt_version = 4; /* since 2.3.99pre4 */
 	}
-	if (nfs_mount_version > NFS_MOUNT_VERSION)
-	     nfs_mount_version = NFS_MOUNT_VERSION;
-	return nfs_mount_version;
-}
-
-static struct pmap *
-get_mountport(struct sockaddr_in *server_addr,
-      long unsigned prog,
-      long unsigned version,
-      long unsigned proto,
-      long unsigned port,
-      int nfs_mount_version)
-{
-	struct pmaplist *pmap;
-	static struct pmap p = {0, 0, 0, 0};
-
-	if (version > MAX_NFSPROT)
-		version = MAX_NFSPROT;
-	if (!prog)
-		prog = MOUNTPROG;
-	p.pm_prog = prog;
-	p.pm_vers = version;
-	p.pm_prot = proto;
-	p.pm_port = port;
-
-	server_addr->sin_port = PMAPPORT;
-	pmap = pmap_getmaps(server_addr);
-
-	while (pmap) {
-		if (pmap->pml_map.pm_prog != prog)
-			goto next;
-		if (!version && p.pm_vers > pmap->pml_map.pm_vers)
-			goto next;
-		if (version > 2 && pmap->pml_map.pm_vers != version)
-			goto next;
-		if (version && version <= 2 && pmap->pml_map.pm_vers > 2)
-			goto next;
-		if (pmap->pml_map.pm_vers > MAX_NFSPROT ||
-		    (proto && p.pm_prot && pmap->pml_map.pm_prot != proto) ||
-		    (port && pmap->pml_map.pm_port != port))
-			goto next;
-		memcpy(&p, &pmap->pml_map, sizeof(p));
-	next:
-		pmap = pmap->pml_next;
-	}
-	if (!p.pm_vers)
-		p.pm_vers = MOUNTVERS;
-	if (!p.pm_prot)
-		p.pm_prot = IPPROTO_TCP;
-#if 0
-	if (!p.pm_port) {
-		p.pm_port = pmap_getport(server_addr, p.pm_prog, p.pm_vers,
-					 p.pm_prot);
+	if (mnt_version > NFS_MOUNT_VERSION)
+	     mnt_version = NFS_MOUNT_VERSION;
+	return mnt_version;
+}
+
+static int
+nfs_gethostbyname(const char *hostname, struct sockaddr_in *saddr)
+{
+	struct hostent *hp;
+
+	saddr->sin_family = AF_INET;
+	if (!inet_aton(hostname, &saddr->sin_addr)) {
+		if ((hp = gethostbyname(hostname)) == NULL) {
+			fprintf(stderr, _("mount: can't get address for %s\n"),
+				hostname);
+			return 0;
+		} else {
+			if (hp->h_length > sizeof(*saddr)) {
+				fprintf(stderr,
+					_("mount: got bad hp->h_length\n"));
+				hp->h_length = sizeof(*saddr);
+			}
+			memcpy(&saddr->sin_addr, hp->h_addr, hp->h_length);
+		}
+	}
+	return 1;
+}
+
+/*
+ * Sigh... pmap_getport() doesn't actually check the version number.
+ * In order to make sure that the server actually supports the service
+ * we're requesting, we open and RPC client, and fire off a NULL
+ * RPC call.
+ */
+static int
+clnt_ping(struct sockaddr_in *saddr, const u_long prog, const u_long vers,
+	  const u_int prot)
+{
+	CLIENT *clnt;
+	int sock, stat;
+	static char clnt_res;
+
+	sock = RPC_ANYSOCK;
+	switch(prot) {
+	case IPPROTO_UDP:
+		clnt = clntudp_bufcreate(saddr, prog, vers,
+					 RETRY_TIMEOUT, &sock,
+					 RPCSMALLMSGSIZE, RPCSMALLMSGSIZE);
+		break;
+	case IPPROTO_TCP:
+		clnt = clnttcp_create(saddr, prog, vers, &sock,
+				      RPCSMALLMSGSIZE, RPCSMALLMSGSIZE);
+		break;
+	default:
+		goto out_bad;
+	}
+	if (!clnt)
+		goto out_bad;
+	memset(&clnt_res, 0, sizeof(clnt_res));
+	stat = clnt_call(clnt, NULLPROC,
+			 (xdrproc_t)xdr_void, (caddr_t)NULL,
+			 (xdrproc_t)xdr_void, (caddr_t)&clnt_res,
+			 TIMEOUT);
+	clnt_destroy(clnt);
+	close(sock);
+	if (stat != RPC_PROGVERSMISMATCH)
+		return 1;
+ out_bad:
+	return 0;
+}
+
+/*
+ * Use the portmapper to discover whether or not the service we want is
+ * available. The lists 'versions' and 'protos' define ordered sequences
+ * of service versions and udp/tcp protocols to probe for.
+ */
+static int
+probe_port(clnt_addr_t *server,
+	   const u_long *versions,
+	   const u_int *protos)
+{
+	struct sockaddr_in *saddr = &server->saddr;
+	struct pmap *pmap = &server->pmap;
+	const u_long prog = pmap->pm_prog,
+		vers = pmap->pm_vers,
+		*p_vers;
+	const u_int prot = (u_int)pmap->pm_prot,
+		*p_prot;
+	const u_short port = (u_short) pmap->pm_port;
+	u_short p_port;
+
+	p_prot = prot ? &prot : protos;
+	p_vers = vers ? &vers : versions;
+	for (;;) {
+		saddr->sin_port = htons(PMAPPORT);
+		p_port = pmap_getport(saddr, prog, *p_vers, *p_prot);
+		if (p_port) {
+			if (!port || port == p_port) {
+				saddr->sin_port = htons(port);
+				if (clnt_ping(saddr, prog, *p_vers, *p_prot))
+					goto out_ok;
+			}
+		} else if (rpc_createerr.cf_stat != RPC_PROGNOTREGISTERED)
+			break;
+		if (!prot) {
+			if (*++p_prot)
+				continue;
+			p_prot = protos;
+		}
+		if (vers || !*++p_vers)
+			break;
+	}
+	return 0;
+ out_ok:
+	if (!vers)
+		pmap->pm_vers = *p_vers;
+	if (!prot)
+		pmap->pm_prot = *p_prot;
+	if (!port)
+		pmap->pm_port = p_port;
+	return 1;
+}
+
+static int
+probe_nfsport(clnt_addr_t *nfs_server)
+{
+	const struct pmap *pmap = &nfs_server->pmap;
+	const u_long *probe_vers;
+	const u_int *probe_prot;
+
+	if (pmap->pm_vers && pmap->pm_prot && pmap->pm_port)
+		return 1;
+	probe_vers = nfs_probelist(MAX_NFSPROT);
+	probe_prot = proto_probelist(HAVE_RELIABLE_TCP);
+	return probe_port(nfs_server, probe_vers, probe_prot);
+}
+
+static int
+probe_mntport(clnt_addr_t *mnt_server)
+{
+	const struct pmap *pmap = &mnt_server->pmap;
+	const u_long *probe_vers;
+	const u_int *probe_prot;
+
+	if (pmap->pm_vers && pmap->pm_prot && pmap->pm_port)
+		return 1;
+	probe_vers = mnt_probelist(MAX_MNTPROT);
+	probe_prot = proto_probelist(HAVE_RELIABLE_TCP);
+	return probe_port(mnt_server, probe_vers, probe_prot);
+}
+
+static int
+probe_bothports(clnt_addr_t *mnt_server, clnt_addr_t *nfs_server)
+{
+	struct pmap *nfs_pmap = &nfs_server->pmap;
+	struct pmap *mnt_pmap = &mnt_server->pmap;
+	struct pmap save_nfs, save_mnt;
+	int res;
+	const u_long *probe_vers;
+
+	if (mnt_pmap->pm_vers && !nfs_pmap->pm_vers)
+		nfs_pmap->pm_vers = mntvers_to_nfs(mnt_pmap->pm_vers);
+	else if (nfs_pmap->pm_vers && !mnt_pmap->pm_vers)
+		mnt_pmap->pm_vers = nfsvers_to_mnt(nfs_pmap->pm_vers);
+	if (nfs_pmap->pm_vers)
+		goto version_fixed;
+	memcpy(&save_nfs, nfs_pmap, sizeof(save_nfs));
+	memcpy(&save_mnt, mnt_pmap, sizeof(save_mnt));
+	for (probe_vers = mnt_probelist(MAX_MNTPROT); *probe_vers; probe_vers++) {
+		nfs_pmap->pm_vers = mntvers_to_nfs(*probe_vers);
+		if ((res = probe_nfsport(nfs_server) != 0)) {
+			mnt_pmap->pm_vers = *probe_vers;
+			if ((res = probe_mntport(mnt_server)) != 0)
+				return 1;
+			memcpy(mnt_pmap, &save_mnt, sizeof(*mnt_pmap));
+		}
+		memcpy(nfs_pmap, &save_nfs, sizeof(*nfs_pmap));
 	}
+ out_bad:
+	return 0;
+ version_fixed:
+	if (!probe_nfsport(nfs_server))
+		goto out_bad;
+	return probe_mntport(mnt_server);
+}
+
+static CLIENT *
+mnt_openclnt(clnt_addr_t *mnt_server, int *msock, const int report_errs)
+{
+	struct sockaddr_in *mnt_saddr = &mnt_server->saddr;
+	struct pmap *mnt_pmap = &mnt_server->pmap;
+	CLIENT *clnt;
+
+	/* contact the mount daemon via TCP */
+	mnt_saddr->sin_port = htons((u_short)mnt_pmap->pm_port);
+	*msock = RPC_ANYSOCK;
+
+	switch (mnt_pmap->pm_prot) {
+	case IPPROTO_UDP:
+		clnt = clntudp_bufcreate(mnt_saddr,
+					 mnt_pmap->pm_prog, mnt_pmap->pm_vers,
+					 RETRY_TIMEOUT, msock,
+					 MNT_SENDBUFSIZE, MNT_RECVBUFSIZE);
+		break;
+	case IPPROTO_TCP:
+		clnt = clnttcp_create(mnt_saddr,
+				      mnt_pmap->pm_prog, mnt_pmap->pm_vers,
+				      msock,
+				      MNT_SENDBUFSIZE, MNT_RECVBUFSIZE);
+		break;
+	default:
+		goto out_bad;
+	}
+	if (!clnt)
+		goto report_err;
+	/* try to mount hostname:dirname */
+	clnt->cl_auth = authunix_create_default();
+	return clnt;
+ report_err:
+	if (report_errs)
+		clnt_pcreateerror("mount");
+ out_bad:
+	return NULL;
+}
+
+static inline void
+mnt_closeclnt(CLIENT *clnt, int msock)
+{
+	auth_destroy(clnt->cl_auth);
+	clnt_destroy(clnt);
+	close(msock);
+}
+
+static inline enum clnt_stat
+nfs3_mount(CLIENT *clnt, mnt3arg_t *mnt3arg, mnt3res_t *mnt3res)
+{
+	return clnt_call(clnt, MOUNTPROC3_MNT,
+			 (xdrproc_t) xdr_dirpath, (caddr_t) mnt3arg,
+			 (xdrproc_t) xdr_mountres3, (caddr_t) mnt3res,
+			 TIMEOUT);
+}
+
+static inline enum clnt_stat
+nfs2_mount(CLIENT *clnt, mnt2arg_t *mnt2arg, mnt2res_t *mnt2res)
+{
+	return clnt_call(clnt, MOUNTPROC_MNT,
+			 (xdrproc_t) xdr_dirpath, (caddr_t) mnt2arg,
+			 (xdrproc_t) xdr_fhstatus, (caddr_t) mnt2res,
+			 TIMEOUT);
+}
+
+static int
+nfs_call_mount(clnt_addr_t *mnt_server, clnt_addr_t *nfs_server,
+	       mntarg_t *mntarg, mntres_t *mntres, const int report_errs)
+{
+	CLIENT *clnt;
+	enum clnt_stat stat;
+	int msock;
+
+
+	if (!probe_bothports(mnt_server, nfs_server)) {
+		if (report_errs)
+			fprintf(stderr,_("mount: failed to probe ports on NFS server %s\n"),
+				*nfs_server->hostname);
+		goto out_bad;
+	}
+
+	clnt = mnt_openclnt(mnt_server, &msock, report_errs);
+	if (!clnt)
+		goto out_bad;
+	/* make pointers in xdr_mountres3 NULL so
+	 * that xdr_array allocates memory for us
+	 */
+	memset(mntres, 0, sizeof(*mntres));
+	switch (mnt_server->pmap.pm_vers) {
+	case 3:
+		stat = nfs3_mount(clnt, mntarg, &mntres->nfsv3);
+		break;
+	case 2:
+	case 1:
+		stat = nfs2_mount(clnt, mntarg, &mntres->nfsv2);
+		break;
+	default:
+		goto out_bad;
+	}
+	if (stat != RPC_SUCCESS && report_errs)
+		clnt_perror(clnt, "mount");
+	mnt_closeclnt(clnt, msock);
+	if (stat == RPC_SUCCESS)
+		return 1;
+ out_bad:
+	return 0;
+}
+
+static int
+parse_options(char *old_opts, struct nfs_mount_data *data,
+	      int *bg, int *retry, clnt_addr_t *mnt_server,
+	      clnt_addr_t *nfs_server, char *new_opts, const int opt_size)
+{
+	struct sockaddr_in *mnt_saddr = &mnt_server->saddr;
+	struct pmap *mnt_pmap = &mnt_server->pmap;
+	struct pmap *nfs_pmap = &nfs_server->pmap;
+	int len;
+	char *opt, *opteq;
+	char *mounthost = NULL;
+	char cbuf[128];
+
+	data->flags = 0;
+	*bg = 0;
+
+	len = strlen(new_opts);
+	for (opt = strtok(old_opts, ","); opt; opt = strtok(NULL, ",")) {
+		if (strlen(opt) >= sizeof(cbuf))
+			goto bad_parameter;
+		if ((opteq = strchr(opt, '=')) && isdigit(opteq[1])) {
+			int val = atoi(opteq + 1);
+			*opteq = '\0';
+			if (!strcmp(opt, "rsize"))
+				data->rsize = val;
+			else if (!strcmp(opt, "wsize"))
+				data->wsize = val;
+			else if (!strcmp(opt, "timeo"))
+				data->timeo = val;
+			else if (!strcmp(opt, "retrans"))
+				data->retrans = val;
+			else if (!strcmp(opt, "acregmin"))
+				data->acregmin = val;
+			else if (!strcmp(opt, "acregmax"))
+				data->acregmax = val;
+			else if (!strcmp(opt, "acdirmin"))
+				data->acdirmin = val;
+			else if (!strcmp(opt, "acdirmax"))
+				data->acdirmax = val;
+			else if (!strcmp(opt, "actimeo")) {
+				data->acregmin = val;
+				data->acregmax = val;
+				data->acdirmin = val;
+				data->acdirmax = val;
+			}
+			else if (!strcmp(opt, "retry"))
+				*retry = val;
+			else if (!strcmp(opt, "port"))
+				nfs_pmap->pm_port = val;
+			else if (!strcmp(opt, "mountport"))
+			        mnt_pmap->pm_port = val;
+			else if (!strcmp(opt, "mountprog"))
+				mnt_pmap->pm_prog = val;
+			else if (!strcmp(opt, "mountvers"))
+				mnt_pmap->pm_vers = val;
+			else if (!strcmp(opt, "nfsprog"))
+				nfs_pmap->pm_prog = val;
+			else if (!strcmp(opt, "nfsvers") ||
+				 !strcmp(opt, "vers")) {
+				nfs_pmap->pm_vers = val;
+				opt = "nfsvers";
+#if NFS_MOUNT_VERSION >= 2
+			} else if (!strcmp(opt, "namlen")) {
+				if (nfs_mount_version >= 2)
+					data->namlen = val;
+				else if (!sloppy)
+					goto bad_parameter;
 #endif
-#if 0
-#define MOUNTPORT 635
-	/* HJLu wants to remove all traces of the old default port.
-	   Are there still people running a mount RPC service on this
-	   port without having a portmapper? */
-	if (!p.pm_port)
-		p.pm_port = MOUNTPORT;
-#endif
-	return &p;
+			} else if (!strcmp(opt, "addr")) {
+				/* ignore */;
+				continue;
+			} else if (!sloppy)
+				goto bad_parameter;
+			sprintf(cbuf, "%s=%s,", opt, opteq+1);
+		} else if (opteq) {
+			*opteq = '\0';
+			if (!strcmp(opt, "proto")) {
+				if (!strcmp(opteq+1, "udp")) {
+					nfs_pmap->pm_prot = IPPROTO_UDP;
+#if NFS_MOUNT_VERSION >= 2
+					data->flags &= ~NFS_MOUNT_TCP;
+				} else if (!strcmp(opteq+1, "tcp") &&
+					   nfs_mount_version >= 2) {
+					nfs_pmap->pm_prot = IPPROTO_TCP;
+					data->flags |= NFS_MOUNT_TCP;
+#endif
+				} else if (!sloppy)
+					goto bad_parameter;
+			} else if (!strcmp(opt, "mounthost"))
+			        mounthost=xstrndup(opteq+1,
+						   strcspn(opteq+1," \t\n\r,"));
+			else
+				goto bad_parameter;
+			sprintf(cbuf, "%s=%s,", opt, opteq+1);
+		} else {
+			int val = 1;
+			if (!strncmp(opt, "no", 2)) {
+				val = 0;
+				opt += 2;
+			}
+			if (!strcmp(opt, "bg"))
+				*bg = val;
+			else if (!strcmp(opt, "fg"))
+				*bg = !val;
+			else if (!strcmp(opt, "soft")) {
+				data->flags &= ~NFS_MOUNT_SOFT;
+				if (val)
+					data->flags |= NFS_MOUNT_SOFT;
+			} else if (!strcmp(opt, "hard")) {
+				data->flags &= ~NFS_MOUNT_SOFT;
+				if (!val)
+					data->flags |= NFS_MOUNT_SOFT;
+			} else if (!strcmp(opt, "intr")) {
+				data->flags &= ~NFS_MOUNT_INTR;
+				if (val)
+					data->flags |= NFS_MOUNT_INTR;
+			} else if (!strcmp(opt, "posix")) {
+				data->flags &= ~NFS_MOUNT_POSIX;
+				if (val)
+					data->flags |= NFS_MOUNT_POSIX;
+			} else if (!strcmp(opt, "cto")) {
+				data->flags &= ~NFS_MOUNT_NOCTO;
+				if (!val)
+					data->flags |= NFS_MOUNT_NOCTO;
+			} else if (!strcmp(opt, "ac")) {
+				data->flags &= ~NFS_MOUNT_NOAC;
+				if (!val)
+					data->flags |= NFS_MOUNT_NOAC;
+#if NFS_MOUNT_VERSION >= 2
+			} else if (!strcmp(opt, "tcp")) {
+				data->flags &= ~NFS_MOUNT_TCP;
+				if (val) {
+					if (nfs_mount_version < 2)
+						goto bad_option;
+					nfs_pmap->pm_prot = IPPROTO_TCP;
+					data->flags |= NFS_MOUNT_TCP;
+				} else
+					nfs_pmap->pm_prot = IPPROTO_UDP;
+			} else if (!strcmp(opt, "udp")) {
+				data->flags &= ~NFS_MOUNT_TCP;
+				if (!val) {
+					if (nfs_mount_version < 2)
+						goto bad_option;
+					nfs_pmap->pm_prot = IPPROTO_TCP;
+					data->flags |= NFS_MOUNT_TCP;
+				} else
+					nfs_pmap->pm_prot = IPPROTO_UDP;
+#endif
+#if NFS_MOUNT_VERSION >= 3
+			} else if (!strcmp(opt, "lock")) {
+				data->flags &= ~NFS_MOUNT_NONLM;
+				if (!val) {
+					if (nfs_mount_version < 3)
+						goto bad_option;
+					data->flags |= NFS_MOUNT_NONLM;
+				}
+#endif
+#if NFS_MOUNT_VERSION >= 4
+			} else if (!strcmp(opt, "broken_suid")) {
+				data->flags &= ~NFS_MOUNT_BROKEN_SUID;
+				if (val) {
+					if (nfs_mount_version < 4)
+						goto bad_option;
+					data->flags |= NFS_MOUNT_BROKEN_SUID;
+				}
+#endif
+			} else {
+			bad_option:
+				printf(_("Unsupported nfs mount option: "
+					 "%s%s\n"), val ? "" : "no", opt);
+				goto out_bad;
+			}
+			sprintf(cbuf, val ? "%s,":"no%s,", opt);
+		}
+		len += strlen(cbuf);
+		if (len >= opt_size) {
+			printf(_("mount: excessively long option argument\n"));
+			goto out_bad;
+		}
+		strcat(new_opts, cbuf);
+	}
+	/* See if the nfs host = mount host. */
+	if (mounthost) {
+		if (!nfs_gethostbyname(mounthost, mnt_saddr))
+			goto out_bad;
+		*mnt_server->hostname = mounthost;
+	}
+	return 1;
+ bad_parameter:
+	printf(_("Bad nfs mount parameter: %s\n"), opt);
+ out_bad:
+	return 0;
+}
+
+static inline int
+nfsmnt_check_compat(const struct pmap *nfs_pmap, const struct pmap *mnt_pmap)
+{
+	if (nfs_pmap->pm_vers > MAX_NFSPROT) {
+		fprintf(stderr, _("NFSv%ld not supported!\n"), nfs_pmap->pm_vers);
+		goto out_bad;
+	}
+	if (mnt_pmap->pm_vers > MAX_MNTPROT) {
+		fprintf(stderr, _("NFS mount v%ld not supported!\n"), mnt_pmap->pm_vers);
+		goto out_bad;
+	}
+	return 1;
+ out_bad:
+	return 0;
 }
 
-int nfsmount(const char *spec, const char *node, int *flags,
-	     char **extra_opts, char **mount_opts, int *nfs_mount_vers,
-	     int running_bg)
+int
+nfsmount(const char *spec, const char *node, int *flags,
+	 char **extra_opts, char **mount_opts, int *nfs_mount_vers,
+	 int running_bg)
 {
 	static char *prev_bg_host;
 	char hostdir[1024];
-	CLIENT *mclient;
 	char *hostname, *dirname, *old_opts, *mounthost = NULL;
-	char new_opts[1024];
-	struct timeval total_timeout;
-	enum clnt_stat clnt_stat;
+	char new_opts[1024], cbuf[20];
 	static struct nfs_mount_data data;
-	char *opt, *opteq;
-	int nfs_mount_version;
 	int val;
-	struct hostent *hp;
-	struct sockaddr_in server_addr;
-	struct sockaddr_in mount_server_addr;
-	struct pmap *pm_mnt;
-	int msock, fsock;
-	struct timeval retry_timeout;
-	union {
-		struct fhstatus nfsv2;
-		struct mountres3 nfsv3;
-	} status;
+
+	clnt_addr_t mnt_server = { &mounthost, };
+	clnt_addr_t nfs_server = { &hostname, };
+	struct sockaddr_in *nfs_saddr = &nfs_server.saddr;
+	struct pmap  *mnt_pmap = &mnt_server.pmap,
+		     *nfs_pmap = &nfs_server.pmap;
+	struct pmap  save_mnt, save_nfs;
+
+	int fsock;
+
+	mntres_t mntres;
+
 	struct stat statbuf;
-	char *s;
-	int port, mountport, proto, bg, soft, intr;
-	int posix, nocto, noac, nolock, broken_suid;
-	int retry, tcp;
-	int mountprog, mountvers, nfsprog, nfsvers;
+	char *s, *p;
+	int bg, retry;
 	int retval;
 	time_t t;
 	time_t prevt;
@@ -231,8 +756,7 @@ int nfsmount(const char *spec, const cha
 	nfs_mount_version = *nfs_mount_vers;
 
 	retval = EX_FAIL;
-	msock = fsock = -1;
-	mclient = NULL;
+	fsock = -1;
 	if (strlen(spec) >= sizeof(hostdir)) {
 		fprintf(stderr, _("mount: "
 				  "excessively long host:dir argument\n"));
@@ -258,49 +782,23 @@ int nfsmount(const char *spec, const cha
 		goto fail;
 	}
 
-	server_addr.sin_family = AF_INET;
-#ifdef HAVE_inet_aton
-	if (!inet_aton(hostname, &server_addr.sin_addr))
-#endif
-	{
-		if ((hp = gethostbyname(hostname)) == NULL) {
-			fprintf(stderr, _("mount: can't get address for %s\n"),
-				hostname);
-			goto fail;
-		} else {
-			if (hp->h_length > sizeof(struct in_addr)) {
-				fprintf(stderr,
-					_("mount: got bad hp->h_length\n"));
-				hp->h_length = sizeof(struct in_addr);
-			}
-			memcpy(&server_addr.sin_addr,
-			       hp->h_addr, hp->h_length);
-		}
-	}
-
-	memcpy (&mount_server_addr, &server_addr, sizeof (mount_server_addr));
+	if (!nfs_gethostbyname(hostname, nfs_saddr))
+		goto fail;
+	mounthost = hostname;
+	memcpy (&mnt_server.saddr, nfs_saddr, sizeof (mnt_server.saddr));
 
 	/* add IP address to mtab options for use when unmounting */
 
-	s = inet_ntoa(server_addr.sin_addr);
+	s = inet_ntoa(nfs_saddr->sin_addr);
 	old_opts = *extra_opts;
 	if (!old_opts)
 		old_opts = "";
-	if (strlen(old_opts) + strlen(s) + 10 >= sizeof(new_opts)) {
-		fprintf(stderr, _("mount: "
-				  "excessively long option argument\n"));
-		goto fail;
-	}
-	sprintf(new_opts, "%s%saddr=%s",
-		old_opts, *old_opts ? "," : "", s);
-	*extra_opts = xstrdup(new_opts);
 
 	/* Set default options.
 	 * rsize/wsize (and bsize, for ver >= 3) are left 0 in order to
 	 * let the kernel decide.
 	 * timeo is filled in after we know whether it'll be TCP or UDP. */
 	memset(&data, 0, sizeof(data));
-	data.retrans	= 3;
 	data.acregmin	= 3;
 	data.acregmax	= 60;
 	data.acdirmin	= 30;
@@ -310,167 +808,21 @@ int nfsmount(const char *spec, const cha
 #endif
 
 	bg = 0;
-	soft = 0;
-	intr = 0;
-	posix = 0;
-	nocto = 0;
-	nolock = 0;
-	broken_suid = 0;
-	noac = 0;
 	retry = 10000;		/* 10000 minutes ~ 1 week */
-	tcp = 0;
 
-	mountprog = MOUNTPROG;
-	mountvers = 0;
-	port = 0;
-	mountport = 0;
-	nfsprog = NFS_PROGRAM;
-	nfsvers = 0;
+	memset(mnt_pmap, 0, sizeof(*mnt_pmap));
+	mnt_pmap->pm_prog = MOUNTPROG;
+	memset(nfs_pmap, 0, sizeof(*nfs_pmap));
+	nfs_pmap->pm_prog = NFS_PROGRAM;
 
 	/* parse options */
+	new_opts[0] = 0;
+	if (!parse_options(old_opts, &data, &bg, &retry, &mnt_server, &nfs_server,
+			   new_opts, sizeof(new_opts)))
+		goto fail;
+	if (!nfsmnt_check_compat(nfs_pmap, mnt_pmap))
+		goto fail;
 
-	for (opt = strtok(old_opts, ","); opt; opt = strtok(NULL, ",")) {
-		if ((opteq = strchr(opt, '='))) {
-			val = atoi(opteq + 1);	
-			*opteq = '\0';
-			if (!strcmp(opt, "rsize"))
-				data.rsize = val;
-			else if (!strcmp(opt, "wsize"))
-				data.wsize = val;
-			else if (!strcmp(opt, "timeo"))
-				data.timeo = val;
-			else if (!strcmp(opt, "retrans"))
-				data.retrans = val;
-			else if (!strcmp(opt, "acregmin"))
-				data.acregmin = val;
-			else if (!strcmp(opt, "acregmax"))
-				data.acregmax = val;
-			else if (!strcmp(opt, "acdirmin"))
-				data.acdirmin = val;
-			else if (!strcmp(opt, "acdirmax"))
-				data.acdirmax = val;
-			else if (!strcmp(opt, "actimeo")) {
-				data.acregmin = val;
-				data.acregmax = val;
-				data.acdirmin = val;
-				data.acdirmax = val;
-			}
-			else if (!strcmp(opt, "retry"))
-				retry = val;
-			else if (!strcmp(opt, "port"))
-				port = val;
-			else if (!strcmp(opt, "mountport"))
-			        mountport = val;
-			else if (!strcmp(opt, "mounthost"))
-			        mounthost=xstrndup(opteq+1,
-						   strcspn(opteq+1," \t\n\r,"));
-			else if (!strcmp(opt, "mountprog"))
-				mountprog = val;
-			else if (!strcmp(opt, "mountvers"))
-				mountvers = val;
-			else if (!strcmp(opt, "nfsprog"))
-				nfsprog = val;
-			else if (!strcmp(opt, "nfsvers") ||
-				 !strcmp(opt, "vers"))
-				nfsvers = val;
-			else if (!strcmp(opt, "proto")) {
-				if (!strncmp(opteq+1, "tcp", 3))
-					tcp = 1;
-				else if (!strncmp(opteq+1, "udp", 3))
-					tcp = 0;
-				else
-					printf(_("Warning: Unrecognized proto= option.\n"));
-			} else if (!strcmp(opt, "namlen")) {
-#if NFS_MOUNT_VERSION >= 2
-				if (nfs_mount_version >= 2)
-					data.namlen = val;
-				else
-#endif
-					printf(_("Warning: Option namlen is not supported.\n"));
-			} else if (!strcmp(opt, "addr")) {
-				/* ignore */;
-			} else {
-				printf(_("unknown nfs mount parameter: "
-					 "%s=%d\n"), opt, val);
-				goto fail;
-			}
-		} else {
-			val = 1;
-			if (!strncmp(opt, "no", 2)) {
-				val = 0;
-				opt += 2;
-			}
-			if (!strcmp(opt, "bg")) 
-				bg = val;
-			else if (!strcmp(opt, "fg")) 
-				bg = !val;
-			else if (!strcmp(opt, "soft"))
-				soft = val;
-			else if (!strcmp(opt, "hard"))
-				soft = !val;
-			else if (!strcmp(opt, "intr"))
-				intr = val;
-			else if (!strcmp(opt, "posix"))
-				posix = val;
-			else if (!strcmp(opt, "cto"))
-				nocto = !val;
-			else if (!strcmp(opt, "ac"))
-				noac = !val;
-			else if (!strcmp(opt, "tcp"))
-				tcp = val;
-			else if (!strcmp(opt, "udp"))
-				tcp = !val;
-			else if (!strcmp(opt, "lock")) {
-				if (nfs_mount_version >= 3)
-					nolock = !val;
-				else
-					printf(_("Warning: option nolock is not supported.\n"));
-			} else if (!strcmp(opt, "broken_suid")) {
-				broken_suid = val;
-			} else {
-				if (!sloppy) {
-					printf(_("unknown nfs mount option: "
-						 "%s%s\n"), val ? "" : "no", opt);
-					goto fail;
-				}
-			}
-		}
-	}
-	proto = (tcp) ? IPPROTO_TCP : IPPROTO_UDP;
-
-	data.flags = (soft ? NFS_MOUNT_SOFT : 0)
-		| (intr ? NFS_MOUNT_INTR : 0)
-		| (posix ? NFS_MOUNT_POSIX : 0)
-		| (nocto ? NFS_MOUNT_NOCTO : 0)
-		| (noac ? NFS_MOUNT_NOAC : 0);
-#if NFS_MOUNT_VERSION >= 2
-	if (nfs_mount_version >= 2)
-		data.flags |= (tcp ? NFS_MOUNT_TCP : 0);
-#endif
-#if NFS_MOUNT_VERSION >= 3
-	if (nfs_mount_version >= 3)
-		data.flags |= (nolock ? NFS_MOUNT_NONLM : 0);
-#endif
-#if NFS_MOUNT_VERSION >= 4
-	if (nfs_mount_version >= 4)
-		data.flags |= (broken_suid ? NFS_MOUNT_BROKEN_SUID : 0);
-#endif
-	if (nfsvers > MAX_NFSPROT) {
-		fprintf(stderr, "NFSv%d not supported!\n", nfsvers);
-		return 0;
-	}
-	if (mountvers > MAX_NFSPROT) {
-		fprintf(stderr, "NFSv%d not supported!\n", nfsvers);
-		return 0;
-	}
-	if (nfsvers && !mountvers)
-		mountvers = (nfsvers < 3) ? 1 : nfsvers;
-	if (nfsvers && nfsvers < mountvers)
-		mountvers = nfsvers;
-
-	/* Adjust options if none specified */
-	if (!data.timeo)
-		data.timeo = tcp ? 70 : 7;
 
 #ifdef NFS_MOUNT_DEBUG
 	printf("rsize = %d, wsize = %d, timeo = %d, retrans = %d\n",
@@ -478,9 +830,10 @@ int nfsmount(const char *spec, const cha
 	printf("acreg (min, max) = (%d, %d), acdir (min, max) = (%d, %d)\n",
 	       data.acregmin, data.acregmax, data.acdirmin, data.acdirmax);
 	printf("port = %d, bg = %d, retry = %d, flags = %.8x\n",
-	       port, bg, retry, data.flags);
+	       nfs_pmap->pm_port, bg, retry, data.flags);
 	printf("mountprog = %d, mountvers = %d, nfsprog = %d, nfsvers = %d\n",
-	       mountprog, mountvers, nfsprog, nfsvers);
+	       mnt_pmap->pm_prog, mnt_pmap->pm_vers,
+	       nfs_pmap->pm_prog, nfs_pmap->pm_vers);
 	printf("soft = %d, intr = %d, posix = %d, nocto = %d, noac = %d\n",
 	       (data.flags & NFS_MOUNT_SOFT) != 0,
 	       (data.flags & NFS_MOUNT_INTR) != 0,
@@ -497,7 +850,7 @@ int nfsmount(const char *spec, const cha
 	*mount_opts = (char *) &data;
 
 	if (*flags & MS_REMOUNT)
-		return 0;
+		goto out_ok;
 
 	/*
 	 * If the previous mount operation on the same host was
@@ -512,28 +865,6 @@ int nfsmount(const char *spec, const cha
 	}
 
 	/* create mount deamon client */
-	/* See if the nfs host = mount host. */
-	if (mounthost) {
-		if (mounthost[0] >= '0' && mounthost[0] <= '9') {
-			mount_server_addr.sin_family = AF_INET;
-			mount_server_addr.sin_addr.s_addr = inet_addr(hostname);
-		} else {
-			if ((hp = gethostbyname(mounthost)) == NULL) {
-				fprintf(stderr, _("mount: can't get address for %s\n"),
-					mounthost);
-				goto fail;
-			} else {
-				if (hp->h_length > sizeof(struct in_addr)) {
-					fprintf(stderr,
-						_("mount: got bad hp->h_length?\n"));
-					hp->h_length = sizeof(struct in_addr);
-				}
-				mount_server_addr.sin_family = AF_INET;
-				memcpy(&mount_server_addr.sin_addr,
-				       hp->h_addr, hp->h_length);
-			}
-		}
-	}
 
 	/*
 	 * The following loop implements the mount retries. On the first
@@ -551,15 +882,13 @@ int nfsmount(const char *spec, const cha
 	 *
 	 * Only the first error message will be displayed.
 	 */
-	retry_timeout.tv_sec = 3;
-	retry_timeout.tv_usec = 0;
-	total_timeout.tv_sec = 20;
-	total_timeout.tv_usec = 0;
 	timeout = time(NULL) + 60 * retry;
 	prevt = 0;
 	t = 30;
 	val = 1;
 
+	memcpy(&save_nfs, nfs_pmap, sizeof(save_nfs));
+	memcpy(&save_mnt, mnt_pmap, sizeof(save_mnt));
 	for (;;) {
 		if (bg && stat(node, &statbuf) == -1) {
 			/* no mount point yet - sleep */
@@ -570,89 +899,18 @@ int nfsmount(const char *spec, const cha
 					val = 30;
 			}
 		} else {
+			int stat;
 			/* be careful not to use too many CPU cycles */
 			if (t - prevt < 30)
 				sleep(30);
 
-			pm_mnt = get_mountport(&mount_server_addr,
-					       mountprog,
-					       mountvers,
-					       proto,
-					       mountport,
-					       nfs_mount_version);
-
-			/* contact the mount daemon via TCP */
-			mount_server_addr.sin_port = htons(pm_mnt->pm_port);
-			msock = RPC_ANYSOCK;
-
-			switch (pm_mnt->pm_prot) {
-			case IPPROTO_UDP:
-				mclient = clntudp_create(&mount_server_addr,
-							 pm_mnt->pm_prog,
-							 pm_mnt->pm_vers,
-							 retry_timeout,
-							 &msock);
-				if (mclient)
-					break;
-				mount_server_addr.sin_port =
-					htons(pm_mnt->pm_port);
-				msock = RPC_ANYSOCK;
-			case IPPROTO_TCP:
-				mclient = clnttcp_create(&mount_server_addr,
-							 pm_mnt->pm_prog,
-							 pm_mnt->pm_vers,
-							 &msock, 0, 0);
+			stat = nfs_call_mount(&mnt_server, &nfs_server,
+					      &dirname, &mntres,
+					      !running_bg && prevt == 0);
+			if (stat)
 				break;
-			default:
-				mclient = 0;
-			}
-
-			if (mclient) {
-				/* try to mount hostname:dirname */
-				mclient->cl_auth = authunix_create_default();
-
-				/* make pointers in xdr_mountres3 NULL so
-				 * that xdr_array allocates memory for us
-				 */
-				memset(&status, 0, sizeof(status));
-
-				if (pm_mnt->pm_vers == 3)
-					clnt_stat = clnt_call(mclient,
-						     MOUNTPROC3_MNT,
-						     (xdrproc_t) xdr_dirpath,
-						     (caddr_t) &dirname,
-						     (xdrproc_t) xdr_mountres3,
-						     (caddr_t) &status,
-						     total_timeout);
-				else
-					clnt_stat = clnt_call(mclient,
-						     MOUNTPROC_MNT,
-						     (xdrproc_t) xdr_dirpath,
-						     (caddr_t) &dirname,
-						     (xdrproc_t) xdr_fhstatus,
-						     (caddr_t) &status,
-						     total_timeout);
-
-				if (clnt_stat == RPC_SUCCESS)
-					break;		/* we're done */
-#if 0
-				/* errno? who sets errno? */
-				/* this fragment breaks bg mounting */
-				if (errno != ECONNREFUSED) {
-					clnt_perror(mclient, "mount");
-					goto fail;	/* don't retry */
-				}
-#endif
-				if (!running_bg && prevt == 0)
-					clnt_perror(mclient, "mount");
-				auth_destroy(mclient->cl_auth);
-				clnt_destroy(mclient);
-				mclient = 0;
-				close(msock);
-			} else {
-				if (!running_bg && prevt == 0)
-					clnt_pcreateerror("mount");
-			}
+			memcpy(nfs_pmap, &save_nfs, sizeof(*nfs_pmap));
+			memcpy(mnt_pmap, &save_mnt, sizeof(*mnt_pmap));
 			prevt = t;
 		}
 
@@ -668,36 +926,35 @@ int nfsmount(const char *spec, const cha
 		if (t >= timeout)
 			goto fail;
 	}
-	nfsvers = (pm_mnt->pm_vers < 2) ? 2 : pm_mnt->pm_vers;
 
-	if (nfsvers == 2) {
-		if (status.nfsv2.fhs_status != 0) {
+	if (nfs_pmap->pm_vers == 2) {
+		if (mntres.nfsv2.fhs_status != 0) {
 			fprintf(stderr,
-				"mount: %s:%s failed, reason given by server: %s\n",
+				_("mount: %s:%s failed, reason given by server: %s\n"),
 				hostname, dirname,
-				nfs_strerror(status.nfsv2.fhs_status));
+				nfs_strerror(mntres.nfsv2.fhs_status));
 			goto fail;
 		}
 		memcpy(data.root.data,
-		       (char *) status.nfsv2.fhstatus_u.fhs_fhandle,
+		       (char *) mntres.nfsv2.fhstatus_u.fhs_fhandle,
 		       NFS_FHSIZE);
 #if NFS_MOUNT_VERSION >= 4
 		data.root.size = NFS_FHSIZE;
 		memcpy(data.old_root.data,
-		       (char *) status.nfsv2.fhstatus_u.fhs_fhandle,
+		       (char *) mntres.nfsv2.fhstatus_u.fhs_fhandle,
 		       NFS_FHSIZE);
 #endif
 	} else {
 #if NFS_MOUNT_VERSION >= 4
 		fhandle3 *fhandle;
-		if (status.nfsv3.fhs_status != 0) {
+		if (mntres.nfsv3.fhs_status != 0) {
 			fprintf(stderr,
-				"mount: %s:%s failed, reason given by server: %s\n",
+				_("mount: %s:%s failed, reason given by server: %s\n"),
 				hostname, dirname,
-				nfs_strerror(status.nfsv3.fhs_status));
+				nfs_strerror(mntres.nfsv3.fhs_status));
 			goto fail;
 		}
-		fhandle = &status.nfsv3.mountres3_u.mountinfo.fhandle;
+		fhandle = &mntres.nfsv3.mountres3_u.mountinfo.fhandle;
 		memset(data.old_root.data, 0, NFS_FHSIZE);
 		memset(&data.root, 0, sizeof(data.root));
 		data.root.size = fhandle->fhandle3_len;
@@ -711,13 +968,9 @@ int nfsmount(const char *spec, const cha
 
 	/* create nfs socket for kernel */
 
-	if (tcp) {
-		if (nfs_mount_version < 3) {
-	     		printf(_("NFS over TCP is not supported.\n"));
-			goto fail;
-		}
+	if (nfs_pmap->pm_prot == IPPROTO_TCP)
 		fsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
-	} else
+	else
 		fsock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
 	if (fsock < 0) {
 		perror(_("nfs socket"));
@@ -727,72 +980,162 @@ int nfsmount(const char *spec, const cha
 		perror(_("nfs bindresvport"));
 		goto fail;
 	}
-	if (port == 0) {
-		server_addr.sin_port = PMAPPORT;
-		port = pmap_getport(&server_addr, nfsprog, nfsvers,
-				    tcp ? IPPROTO_TCP : IPPROTO_UDP);
-#if 1
-		/* Here we check to see if user is mounting with the
-		 * tcp option.  If so, and if the portmap returns a
-		 * '0' for port (service unavailable), we then exit,
-		 * notifying the user, rather than hanging up mount.
-		 */
-		if (port == 0 && tcp == 1) {
-			perror(_("nfs server reported service unavailable"));
-			goto fail;
-		}
-#endif
-
-		if (port == 0)
-			port = NFS_PORT;
 #ifdef NFS_MOUNT_DEBUG
-		else
-			printf(_("used portmapper to find NFS port\n"));
+	printf(_("using port %d for nfs deamon\n"), nfs_pmap->pm_port);
 #endif
-	}
-#ifdef NFS_MOUNT_DEBUG
-	printf(_("using port %d for nfs deamon\n"), port);
-#endif
-	server_addr.sin_port = htons(port);
+	nfs_saddr->sin_port = htons(nfs_pmap->pm_port);
 	/*
 	 * connect() the socket for kernels 1.3.10 and below only,
 	 * to avoid problems with multihomed hosts.
 	 * --Swen
 	 */
 	if (linux_version_code() <= 66314
-	    && connect(fsock, (struct sockaddr *) &server_addr,
-		       sizeof (server_addr)) < 0) {
+	    && connect(fsock, (struct sockaddr *) nfs_saddr,
+		       sizeof (*nfs_saddr)) < 0) {
 		perror(_("nfs connect"));
 		goto fail;
 	}
 
+#if NFS_MOUNT_VERSION >= 2
+	if (nfs_pmap->pm_prot == IPPROTO_TCP)
+		data.flags |= NFS_MOUNT_TCP;
+	else
+		data.flags &= ~NFS_MOUNT_TCP;
+#endif
+
 	/* prepare data structure for kernel */
 
 	data.fd = fsock;
-	memcpy((char *) &data.addr, (char *) &server_addr, sizeof(data.addr));
+	memcpy((char *) &data.addr, (char *) nfs_saddr, sizeof(data.addr));
 	strncpy(data.hostname, hostname, sizeof(data.hostname));
 
-	/* clean up */
+ out_ok:
+	/* Ensure we have enough padding for the following strcat()s */
+	if (strlen(new_opts) + strlen(s) + 30 >= sizeof(new_opts)) {
+		fprintf(stderr, _("mount: "
+				  "excessively long option argument\n"));
+		goto fail;
+	}
 
-	auth_destroy(mclient->cl_auth);
-	clnt_destroy(mclient);
-	close(msock);
+	sprintf(cbuf, "addr=%s", s);
+	strcat(new_opts, cbuf);
+
+	*extra_opts = xstrdup(new_opts);
 	return 0;
 
 	/* abort */
-
  fail:
-	if (msock != -1) {
-		if (mclient) {
-			auth_destroy(mclient->cl_auth);
-			clnt_destroy(mclient);
-		}
-		close(msock);
-	}
 	if (fsock != -1)
 		close(fsock);
 	return retval;
-}	
+}
+
+static inline enum clnt_stat
+nfs3_umount(dirpath *argp, CLIENT *clnt)
+{
+	static char clnt_res;
+	memset (&clnt_res, 0, sizeof(clnt_res));
+	return clnt_call(clnt, MOUNTPROC_UMNT,
+			 (xdrproc_t) xdr_dirpath, (caddr_t)argp,
+			 (xdrproc_t) xdr_void, (caddr_t) &clnt_res,
+			 TIMEOUT);
+}
+
+static inline enum clnt_stat
+nfs2_umount(dirpath *argp, CLIENT *clnt)
+{
+	static char clnt_res;
+	memset (&clnt_res, 0, sizeof(clnt_res));
+	return clnt_call(clnt, MOUNTPROC_UMNT,
+			 (xdrproc_t) xdr_dirpath, (caddr_t)argp,
+			 (xdrproc_t) xdr_void, (caddr_t) &clnt_res,
+			 TIMEOUT);
+}
+
+static int
+nfs_call_umount(clnt_addr_t *mnt_server, dirpath *argp)
+{
+	CLIENT *clnt;
+	enum clnt_stat res = 0;
+	int msock;
+
+	clnt = mnt_openclnt(mnt_server, &msock, 1);
+	if (!clnt)
+		goto out_bad;
+	switch (mnt_server->pmap.pm_vers) {
+	case 3:
+		res = nfs3_umount(argp, clnt);
+		break;
+	case 2:
+	case 1:
+		res = nfs2_umount(argp, clnt);
+		break;
+	default:
+	}
+	mnt_closeclnt(clnt, msock);
+	if (res == RPC_SUCCESS)
+		return 1;
+ out_bad:
+	return 0;
+}
+
+int
+nfsumount(const char *spec, const char *opts)
+{
+	char *hostname;
+	char *dirname;
+	clnt_addr_t mnt_server = { &hostname, };
+	struct pmap *pmap = &mnt_server.pmap;
+	char *p;
+
+	nfs_mount_version = find_kernel_nfs_mount_version();
+	if (spec == NULL || (p = strchr(spec,':')) == NULL)
+		goto out_bad;
+	hostname = xstrndup(spec, p-spec);
+	dirname = xstrdup(p+1);
+#ifdef NFS_MOUNT_DEBUG
+	printf(_("host: %s, directory: %s\n"), hostname, dirname);
+#endif
+
+	if (opts && (p = strstr(opts, "addr="))) {
+		char *q;
+
+		free(hostname);
+		p += 5;
+		q = p;
+		while (*q && *q != ',') q++;
+		hostname = xstrndup(p,q-p);
+	}
+
+	if (opts && (p = strstr(opts, "mounthost="))) {
+		char *q;
+
+		free(hostname);
+		p += 10;
+		q = p;
+		while (*q && *q != ',') q++;
+		hostname = xstrndup(p,q-p);
+	}
+
+	pmap->pm_prog = MOUNTPROG;
+	pmap->pm_vers = MOUNTVERS;
+	if (opts && (p = strstr(opts, "mountprog=")) && isdigit(*(p+10)))
+		pmap->pm_prog = atoi(p+10);
+	if (opts && (p = strstr(opts, "mountport=")) && isdigit(*(p+10)))
+		pmap->pm_port = atoi(p+10);
+	if (opts && (p = strstr(opts, "nfsvers=")) && isdigit(*(p+8)))
+		pmap->pm_vers = nfsvers_to_mnt(atoi(p+8));
+	if (opts && (p = strstr(opts, "mountvers=")) && isdigit(*(p+10)))
+		pmap->pm_vers = atoi(p+10);
+
+	if (!nfs_gethostbyname(hostname, &mnt_server.saddr))
+		goto out_bad;
+	if (!probe_mntport(&mnt_server))
+		goto out_bad;
+	return nfs_call_umount(&mnt_server, &dirname);
+ out_bad:
+	return 0;
+}
 
 /*
  * We need to translate between nfs status return values and
diff -puN mount/sundries.h~nfs mount/sundries.h
--- util-linux-2.12/mount/sundries.h~nfs	2004-10-13 13:51:44.000000000 -0400
+++ util-linux-2.12-bfields/mount/sundries.h	2004-10-13 14:13:30.000000000 -0400
@@ -37,6 +37,7 @@ void die (int errcode, const char *fmt, 
 #ifdef HAVE_NFS
 int nfsmount (const char *spec, const char *node, int *flags,
 	      char **orig_opts, char **opt_args, int *version, int running_bg);
+int nfsumount(const char *spec, const char *opts);
 #endif
 
 /* exit status - bits below are ORed */
diff -puN mount/umount.c~nfs mount/umount.c
--- util-linux-2.12/mount/umount.c~nfs	2004-10-13 13:51:44.000000000 -0400
+++ util-linux-2.12-bfields/mount/umount.c	2004-10-13 14:13:30.000000000 -0400
@@ -122,7 +122,7 @@ check_special_umountprog() {
 }
 #endif
 
-#ifdef HAVE_NFS
+#if 0
 static int xdr_dir(XDR *xdrsp, char *dirp)
 {
       return (xdr_string(xdrsp, &dirp, MNTPATHLEN));
@@ -265,7 +265,7 @@ umount_one (const char *spec, const char
 	/* Ignore any RPC errors, so that you can umount the filesystem
 	   if the server is down.  */
 	if (strcasecmp(type, "nfs") == 0)
-		nfs_umount_rpc_call(spec, opts);
+		nfsumount(spec, opts);
 #endif
  
 	umnt_err = umnt_err2 = 0;
_
